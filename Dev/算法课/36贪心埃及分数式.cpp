//思考1. 埃及分数式
//把一个给定的真分数转化为若干个互不相同的埃及分数之和，并约定埃及分数的分母不能与给定分数的分母相同。常把分解式中埃及分数的个数最少，在个数相同时埃及分数中最大分母为最小的分解式称为最优分解式。

#include <stdio.h>

int main() {
    int a, b, c, k, j, t, u, f[2000];
    // 提示用户输入分数的分子和分母
    printf("  请输入分数的分子、分母: ");
    scanf("%d,%d", &a, &b);
    printf("  %d/%d=", a, b);

    // 如果输入的分数本身就是埃及分数（分子为1）或者分母能被分子整除
    if (a == 1 || b % a == 0) {
        printf("  %d/%d \n", 1, b / a);
        return 0;
    }

    k = 0;
    t = 0;
    j = b; // 记录给定分数的分母

    while (1) {
        // 计算当前合适的埃及分数分母
        c = b / a + 1;
        // 检查所得分母是否超过所定上限，若超过则中断循环
        if (c > 1000000000 || c < 0) {
            t = 1;
            break;
        }
        // 保证埃及分数的分母不与给定分数的分母相同
        if (c == j) {
            c++;
        }
        k++;
        f[k] = c; // 记录第k个埃及分数的分母

        // 更新分子和分母，为选择下一个分母作准备
        a = a * c - b;
        b = b * c;

        // 对分子和分母进行化简
        for (u = 2; u <= a; u++) {
            while (a % u == 0 && b % u == 0) {
                a = a / u;
                b = b / u;
            }
        }

        // 若化简后的分数为埃及分数且分母与给定分数分母不同，则记录分母并退出循环
        if (a == 1 && b != j) {
            k++;
            f[k] = b;
            break;
        }
    }

    // 若未超过上限，输出k个埃及分数组成的埃及分数式
    if (t == 0) {
        printf("1/%d", f[1]);
        for (j = 2; j <= k; j++) {
            printf("+1/%d", f[j]);
        }
        printf("\n");
    } 
    // 若超过上限，输出未找到合适埃及分数式的提示
    else {
        printf("  尚未找到合适的埃及分数式！\n");
    }

    return 0;
}

